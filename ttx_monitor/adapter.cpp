// ============================================================================
// xb_monitor: Opensource EX-BOARD loader
// by Romhack
// ============================================================================


#include "stdafx.h"
#include <vector>

using namespace std;

static int isAddressed = 0;
int is_addressed() {
	return isAddressed;
}
void reset_addressed()
{
	isAddressed = 0;
}

unsigned char SRAM[SRAM_SIZE];
void SRAM_save()
{
	FILE *fp = NULL;
	fp = fopen(SRAM_NAME, "wb");
	if (!fp) {
		logmsg("Não foi possível criar o arquivo %s\n", SRAM_NAME);
		return;
	}
	fwrite(SRAM, 1, SRAM_SIZE, fp);
	fclose(fp);
	logmsg("SRAM salva com sucesso!\n");
}

void SRAM_load()
{
	FILE *fp = NULL;
	fp = fopen(SRAM_NAME, "rb");
	memset(SRAM, 0, SRAM_SIZE);
	if (!fp) {
		logmsg("Não foi possível encontrar o arquivo %s\n", SRAM_NAME);
		return;
	}
	fread(SRAM, 1, SRAM_SIZE, fp);
	fclose(fp);
	logmsg("SRAM carregada com sucesso!\n");
}
/*
REPLY FORMAT
76 CC SS nn RR 42

CC - command
SS - size of stream
RR - reply
nn - ???
*/

void SRAM_read(std::vector<char>& dst, unsigned int addr, unsigned char size)
{
	for (unsigned int i = 0; i < size; i++) {
		if (addr < SRAM_SIZE)
			dst.push_back(SRAM[addr]);
		else
			dst.push_back(0);
		addr++;	
	}
}

unsigned char tbl0[120] = {
	0x00, 0x2A, 0x34, 0x2E, 0x20, 0xA1, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x31, 0x24, 0x28, 
	0x80, 0x1A, 0x06, 0x00, 0x07, 0x00, 0x00, 0x00, 0x02, 0x20, 0x32, 0x2C, 0xE0, 0x93, 0x04, 0x00, 
	0x01, 0x00, 0x00, 0x00, 0x03, 0x23, 0x20, 0x36, 0x40, 0x0D, 0x03, 0x00, 0x0A, 0x00, 0x00, 0x00, 
	0x04, 0x2B, 0x28, 0x22, 0xA0, 0x86, 0x01, 0x00, 0x06, 0x00, 0x00, 0x00, 0x05, 0x2A, 0x34, 0x31, 
	0x90, 0x5F, 0x01, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x06, 0x38, 0x34, 0x28, 0x80, 0x38, 0x01, 0x00, 
	0x05, 0x00, 0x00, 0x00, 0x07, 0x23, 0x34, 0x32, 0x70, 0x11, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00, 
	0x08, 0x2D, 0x2E, 0x20, 0x60, 0xEA, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x09, 0x24, 0x35, 0x24, 
	0x50, 0xC3, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00
};

unsigned char tbl1[120] = {
	0x00, 0x2A, 0x34, 0x2E, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x31, 0x24, 0x28, 
	0x09, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x02, 0x20, 0x32, 0x2C, 0x08, 0x00, 0x00, 0x00, 
	0x01, 0x00, 0x00, 0x00, 0x03, 0x23, 0x20, 0x36, 0x07, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 
	0x04, 0x2B, 0x28, 0x22, 0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x05, 0x2A, 0x34, 0x31, 
	0x05, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x06, 0x38, 0x34, 0x28, 0x04, 0x00, 0x00, 0x00, 
	0x05, 0x00, 0x00, 0x00, 0x07, 0x23, 0x34, 0x32, 0x03, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
	0x08, 0x2D, 0x2E, 0x20, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x09, 0x24, 0x35, 0x24, 
	0x01, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00
};

unsigned char tbl2[160] = {
	0x00, 0x2A, 0x34, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x01, 0x31, 0x24, 0x28, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 
	0x02, 0x20, 0x32, 0x2C, 0x00, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
	0x03, 0x23, 0x20, 0x36, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 
	0x04, 0x2B, 0x28, 0x22, 0x00, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
	0x05, 0x2A, 0x34, 0x31, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 
	0x06, 0x38, 0x34, 0x28, 0x00, 0x00, 0x00, 0x00, 0x46, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 
	0x07, 0x23, 0x34, 0x32, 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
	0x08, 0x2D, 0x2E, 0x20, 0x00, 0x00, 0x00, 0x00, 0x5A, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
	0x09, 0x24, 0x35, 0x24, 0x00, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00
};

static vector<char> r(1024);
DWORD process_stream(UINT8 *stream, DWORD srcsize, BYTE *dst, DWORD dstsize)
{
	
	r.clear();

	switch (stream[1]) {
		case 0xfa:
		{
			unsigned int addr = 0;
			unsigned int size = 0;
			r.push_back(0x76);
			r.push_back(0xfa);
			r.push_back(0x05);
			r.push_back(0x70);
			r.push_back(0x42);
//A5 FA 17 00 58 10 02 03 04 05 06 00 01 02 03 04 05 06 00 00 00 00 5A 
			addr = (stream[3] << 8) | (stream[4]);
			size = stream[5];

			if (size >= (srcsize - 1))
				size = srcsize - 1;
			if ((addr + size) >= 0xffff)
				size = 0xffff-addr;

			//logmsg("SRAM WRITE %d : %x\n", size, addr);
			memcpy(&SRAM[addr], &stream[6], size);
			break;
		}
#if 0
		case 0xfb:
			r.push_back(0x76);
			r.push_back(0xfb);
			
			if (stream[4] == 0)
			{
				r.push_back(80+80+5);
				int a3 = 0;
				int a5 = 3;
				for (int i = 0; i < 20; i++) {
					// 3
					if (i & 1) {
						for (int k = 0; k < 3; k++)
							r.push_back(tbl0[a3 + k]);
						a3 += 12;
					} else {
						for (int k = 0; k < 5; k++)
							r.push_back(tbl0[a5 + k]);
						a5 += 12;
					}
				}

				a3 = 1;
				a5 = 4;
				for (int i = 0; i < 20; i++) {
					// 3
					if (i & 1) {
						for (int k = 0; k < 3; k++)
							r.push_back(tbl0[a3 + k]);
						a3 += 12;
					} else {
						for (int k = 0; k < 5; k++)
							r.push_back(tbl0[a5 + k]);
						a5 += 12;
					}
				}
			} else {
				r.push_back(0xf4);
				for (int i = 0; i < 0xef; i++)
					r.push_back(0);
			}
			r.push_back(0x70);
			r.push_back(0x42);
			break;
#else
		case 0xfb:
		{
	//A5 FB 07 00 00 EF 5A 
			r.push_back(0x76);
			r.push_back(0xfb);

			unsigned int addr = 0;
			unsigned int size = stream[5];
			unsigned pos = r.size();
			r.push_back(5);

			addr = (stream[3] << 8) | (stream[4]);
			size = stream[5];

			if ((addr + size) >= 0xffff)
				size = 0xffff-addr;

			for (int i = 0; i < size; i++)
				r.push_back(SRAM[addr++]);

			r[pos] += size;
			//logmsg("SRAM READ %d : %x\n", size, addr);

			r.push_back(0x70);
			r.push_back(0x42);
			break;
		}

#endif
		case 0xfe:
			r.push_back(0x76);
			r.push_back(0xfe);
			r.push_back(0x06);
			if (stream[3]) 
				r.push_back(0x01);
			else
				r.push_back(0);
			r.push_back(0x70);
			r.push_back(0x42);
			break;

		case 0x01:
			r.push_back(0x76);
			r.push_back(0x01);
			r.push_back(0x06);
			r.push_back(0x00);
			r.push_back(0x70);
			r.push_back(0x42);
			isAddressed = 1;
			break;
		case 0x08: // error
			isAddressed = 0;
		default:
			break;
	} 

	BYTE *pdst = dst;
	unsigned i = 0;
	unsigned maxv = r.size();

	if (maxv > dstsize)
		maxv = dstsize;

	for (i = 0; i < maxv; i++)
		*pdst++ = r[i];

	unsigned sz = r.size();
	//r.clear();
	return sz;
}
